# WB Tech: level # 1 (Golang)
## Как делать задания
В заданиях никаких устных решений — только код. Одно решение — один файл с хорошо откомментированным кодом. Каждое решение или невозможность решения надо объяснить.

Разрешается и приветствуется использование любых справочных ресурсов, привлечение сторонних экспертов и т.д. и т.п. 

Основной критерий оценки — четкое понимание «как это работает». Некоторые задачи можно решить несколькими способами, в этом случае требуется привести максимально возможное количество вариантов.

Можно задавать вопросы, как по условию задач, так и об их решении. Идеальный вариант — продемонстрировать свои решения и получить максимальный фидбэк от опытных разработчиков Wildberries.
## Задания
1.	Дана структура Human (с произвольным набором полей и методов). Реализовать встраивание методов в структуре Action от родительской структуры Human (аналог наследования).

2.	Написать программу, которая конкурентно рассчитает значение квадратов чисел взятых из массива (2,4,6,8,10) и выведет их квадраты в stdout.

3.	Дана последовательность чисел: 2,4,6,8,10. Найти сумму их квадратов(22+32+42….) с использованием конкурентных вычислений.

4.	Реализовать постоянную запись данных в канал (главный поток). Реализовать набор из N воркеров, которые читают произвольные данные из канала и выводят в stdout. Необходима возможность выбора количества воркеров при старте. Программа должна завершаться по нажатию Ctrl+C. Выбрать и обосновать способ завершения работы всех воркеров.


5.	Разработать программу, которая будет последовательно отправлять значения в канал, а с другой стороны канала — читать. По истечению N секунд программа должна завершаться.

6.	Реализовать все возможные способы остановки выполнения горутины. 

7.	Реализовать конкурентную запись данных в map.

8.	Дана переменная int64. Разработать программу которая устанавливает i-й бит в 1 или 0.

9.	Разработать конвейер чисел. Даны два канала: в первый пишутся числа (x) из массива, во второй — результат операции x*2, после чего данные из второго канала должны выводиться в stdout.

10.	Дана последовательность температурных колебаний: -25.4, -27.0 13.0, 19.0, 15.5, 24.5, -21.0, 32.5. Объединить данные значения в группы с шагом в 10 градусов. Последовательность в подмножноствах не важна.
    Пример: -20:{-25.0, -27.0, -21.0}, 10:{13.0, 19.0, 15.5}, 20: {24.5}, etc.

12.	Реализовать пересечение двух неупорядоченных множеств.

13.	Имеется последовательность строк - (cat, cat, dog, cat, tree) создать для нее собственное множество.

14.	Поменять местами два числа без создания временной переменной.

15.	Разработать программу, которая в рантайме способна определить тип переменной: int, string, bool, channel из переменной типа interface{}.

16.	К каким негативным последствиям может привести данный фрагмент кода, и как это исправить? Приведите корректный пример реализации.
```
var justString string
func someFunc() {
  v := createHugeString(1 << 10)
  justString = v[:100]
}

func main() {
  someFunc()
}
```
16.	Реализовать быструю сортировку массива (quicksort) встроенными методами языка.

17.	Реализовать бинарный поиск встроенными методами языка.

18.	Реализовать структуру-счетчик, которая будет инкрементироваться в конкурентной среде. По завершению программа должна выводить итоговое значение счетчика.

19.	Разработать программу, которая переворачивает подаваемую на ход строку (например: «главрыба — абырвалг»). Символы могут быть unicode.

20.	Разработать программу, которая переворачивает слова в строке. 
Пример: «snow dog sun — sun dog snow».

21.	Реализовать паттерн «адаптер» на любом примере.

22.	Разработать программу, которая перемножает, делит, складывает, вычитает две числовых переменных a,b, значение которых > 2^20.

23.	Удалить i-ый элемент из слайса.

24.	Разработать программу нахождения расстояния между двумя точками, которые представлены в виде структуры Point с инкапсулированными параметрами x,y и конструктором.

25.	Реализовать собственную функцию sleep.

26.	Разработать программу, которая проверяет, что все символы в строке уникальные (true — если уникальные, false etc). Функция проверки должна быть регистронезависимой.
```
Например: 
abcd — true
abCdefAaf — false
aabcd — false
```

## Устные вопросы

1.	Какой самый эффективный способ конкатенации строк?

  	Cтроки представляют собой неизменяемый слайс(срез) байтов, при конкатенации двух строк происходит выделение новой памяти.
  	Если часто присоединять строки, то будет выделено много памяти.
  	Решить эту проблему может самый эффективный способ конкатенации строк - использование strings.Builder.
    ```go
    var builder strings.Builder
        
    // Выделение памяти заранее, если известно приближенное количество символов.
    estimatedSize := 100
    builder.Grow(estimatedSize)
    
    // Множественные операции конкатенации.
    for i := 0; i < 10; i++ {
        builder.WriteString(fmt.Sprintf("Строка %d\n", i))
    }
    
    result := builder.String()
    ```go
2.	Что такое интерфейсы, как они применяются в Go?

  	Интерфейсы — это инструменты для определения наборов действий и поведения. Интерфейсы — это в первую очередь контракты. Они позволяют объектам опираться на абстракции, а не фактические      реализации других объектов. При этом для компоновки различных поведений можно группировать несколько интерфейсов. В общем смысле — это набор методов, представляющих стандартное              поведение для различных типов данных.

    **Интерфейсный тип**

    В Go интерфейсный тип выглядит вот так:

    ```go
    type iface struct {
        tab  *itab
        data unsafe.Pointer
    }
    ```

    Где `tab` — это указатель на `Interface Table` или `itable` — структуру, которая хранит некоторые метаданные о типе и список методов, используемых для удовлетворения интерфейса, а data указывает на реальную область памяти, в которой лежат данные изначального объекта (статическим типом).

    Компилятор генерирует метаданные для каждого статического типа, в которых, помимо прочего, хранится список методов, реализованных для данного типа. Аналогично генерируются метаданные со списком методов для каждого интерфейса. Теперь, во время исполнения программы, runtime Go может вычислить `itable` на лету (late binding) для каждой конкретной пары. Этот `itable` кешируется, поэтому просчёт происходит только один раз.

    Зная это, становится очевидно, почему Go ловит несоответствия типов на этапе компиляции, но кастинг к интерфейсу — во время исполнения.

    Что важно помнить — переменная интерфейсного типа может принимать `nil`. Но так как объект интерфейса в Go содержит два поля: `tab` и `data` — по правилам Go, интерфейс может быть равен `nil` только если оба этих поля не определены ([faq](https://go.dev/doc/faq#nil_error)):

    ```go
    var (
        builder  *strings.Builder
        stringer fmt.Stringer
    )

    fmt.Println(builder, stringer) // nil nil
    fmt.Println(stringer == nil) // true
    fmt.Println(builder == nil) // true

    stringer = builder

    fmt.Println(builder, stringer) // nil nil
    fmt.Println(stringer == nil) // false (!!!)
    fmt.Println(builder == nil) // true
    ```

    **Пустой interface{}**

    Ему удовлетворяет вообще любой тип. Пустой интерфейс ничего не означает, никакой абстракции. Поэтому использовать пустые интерфейсы нужно в самых крайних случаях.

    На какой стороне описывать интерфейс — на передающей или принимающей?

    Многое зависит от конкретного случая, но по умолчанию описывать интерфейсы следует на принимающей стороне — таким образом, ваш код будет меньше зависеть от какого-то другого кода/пакета/реализации.

    Другими словами, если нам в каком-то месте требуется «что-то что умеет себя закрывать», или — умеет метод Close() error, или (другими словами) удовлетворят интерфейсу:

    ```go
    type something interface {
        Close() error
    }
    ```

    То он (интерфейс) должен быть описан на принимающей стороне. Так принимающая сторона не будет ничего знать о том, что именно в неё может «прилететь», но точно знает поведение этого «чего-то». Таким образом реализуется инверсия зависимости, и код становится проще переиспользовать/тестировать.

    [Вопросы и ответы для собеседования Go-разработчика](https://habr.com/ru/post/658623/)
  	
4.	Чем отличаются RWMutex от Mutex?

  	Mutex и RWMutex обеспечивают механизм блокировки для управления доступом к общим ресурсам. Mutex использует методы Lock и Unlock, чтобы блокировать и разблокировать доступ к ресурсу. В то время как RWMutex предоставляет дополнительные методы RLock и RUnlock для разрешения параллельного чтения ресурса, не блокируя операции RLock/RUnlock, в то время как операции Lock/Unlock блокируют доступ для других операций.
  	
6.	Чем отличаются буферизированные и не буферизированные каналы?

    Буферизированные каналы в Go имеют фиксированный размер и позволяют отправлять данные в канал, даже если нет готовой горутины для их приема. Они обеспечивают асинхронную передачу данных     с возможностью буферизации.

    Не буферизированные каналы требуют синхронной передачи данных, блокируя отправку до тех пор, пока нет готовой горутины для приема данных. Это обеспечивает точную синхронизацию между         горутинами.

7.	Какой размер у структуры struct{}{}? 
    ```go
    var i struct{}
    
	fmt.Println(unsafe.Sizeof(i))
    ```

    ```sh
    0
    ```
8.	Есть ли в Go перегрузка методов или операторов?

    No.

9.	В какой последовательности будут выведены элементы map[int]int?
```
Пример:
m[0]=1
m[1]=124
m[2]=281
```
В рандомной, так как map - это хеш таблица 

8.	В чем разница make и new?

    make используется для создания срезов (slices), карт (maps) и каналов (channels).
  	
  	make возвращает сразу готовую инициализированную структуру данных

    new выделяет память под переменную и возвращает указатель на нее, заполненную zero value типа. Его цель - выделение памяти и возврат указателя.
    
10.	Сколько существует способов задать переменную типа slice или map?

    Для slice:
    
    `emptySlice := []string{}` - Создание пустого среза.
    
    `letterSlice := []string{"a", "b", "c", "d"}` - Создание среза с предварительно заданными элементами.
    
    `var uninitializedSlice []string` - Объявление среза без его инициализации. Срез будет иметь нулевое значение (nil).
    
    `var mySlice []string = []string{"a", "b", "c", "d"}` - Объявление среза c инициализацией.
    
    `makeEmptySlice := make([]string, 0)` - Создание пустого среза с помощью функции make. Эквивалентно первому способу.
    
    `sliceWithCapacity := make([]string, 0, 10)` - Создание среза с указанием емкости (capacity) 10, но с длиной (length) 0.
    
    `slicePointer := new([]string)` - Создание указателя на срез, но срез сам по себе не будет инициализирован.
    
    Для map:
    
    `var emptyMap map[string]string` - Объявление переменной-карты без ее инициализации. Карта будет иметь нулевое значение (nil).
    
    `initializedMap := map[string]string{...}` - Создание и инициализация карты с ключами и значениями.
    
    `makeEmptyMap := make(map[string]string)` - Создание пустой карты с помощью функции make.
    
    `mapWithCapacity := make(map[string]string, 10)` - Создание карты с указанием начальной емкости 10.
    
    `mapPointer := new(map[string]string)` - Создание указателя на карту, но карта сама по себе не будет инициализирована.
    
11.	Что выведет данная программа и почему?
    ```
    func update(p *int) {
      b := 2
      p = &b
    }
    
    func main() {
      var (
         a = 1
         p = &a
      )
      fmt.Println(*p)
      update(p)
      fmt.Println(*p)
    }
    ```
    По умолчанию аргументы передаются по значению, то есть копируются. В данном случае перменная p, объявленная внутри функции update это локальная переменная.
    p скопировала указатель и изменила свое значение, таким образом, локальная перменная просто поменяла значения, не повлияв на p, объявленную в main()
    Таким образом программа выведет:
    ```
    1
    1
    ```

11.	Что выведет данная программа и почему?
    ```
    func main() {
      wg := sync.WaitGroup{}
      for i := 0; i < 5; i++ {
         wg.Add(1)
         go func(wg sync.WaitGroup, i int) {
            fmt.Println(i)
            wg.Done()
         }(wg, i)
      }
      wg.Wait()
      fmt.Println("exit")
    }
    ```
    Дедлок, так как wg передался по значению, таким образом, для wg объекта, объявленного в главной функции, не вызовется Done(),
   	в следствие чего счетчик горутин не уменьшается, wg.Wait() ждет и падает.
    Исправить можно, передав wg в качестве указателя
    
13.	Что выведет данная программа и почему?
    ```
    func main() {
      n := 0
      if true {
         n := 1
         n++
      }
      fmt.Println(n)
    }
    ```
    
    Выведется 0, так как блок, объявленный внутри if, **это другая область видимости**, таким образом внутри создается другая переменная.


13.	Что выведет данная программа и почему?
    ```
    func someAction(v []int8, b int8) {
      v[0] = 100
      v = append(v, b)
    }
    
    func main() {
      var a = []int8{1, 2, 3, 4, 5}
      someAction(a, 6)
      fmt.Println(a)
    }
    ```

    Важно понимать, что слайс - это структура, которая содержит, len, cap и указатель на область памяти, где находится массив. Также слайсы передаются по значению. Строка `v[0] = 100`,          действительно изменит слайс, так как переменная `v` указывает на тот же массив что и `a`, таким образом значение элемента слайса изменится.
    Затем выполняется операция v = append(v, b). Эта операция добавляет число `b` (которое равно 6) в срез `v`. Однако это изменение происходит только внутри функции `someAction`, и оно не      влияет на оригинальный срез `a` из функции main. Поэтому срез `a` в функции main остается неизменным.
    В результате выведется:
    ```
    [100 2 3 4 5]
    ```



14.	Что выведет данная программа и почему?
    ```
    func main() {
      slice := []string{"a", "a"}
    
      func(slice []string) {
         slice = append(slice, "a")
         slice[0] = "b"
         slice[1] = "b"
         fmt.Print(slice)
      }(slice)
      fmt.Print(slice)
    }
    ```

   	В данной программе срез передается в анонимную функцию как параметр, и этот срез копируется внутри функции. Поэтому любые изменения, сделанные внутри этой функции, не влияют на         
    оригинальный срез в главной функции main.
